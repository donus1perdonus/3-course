## DAA — OpenMP Matrix Multiplication Benchmark

Проект демонстрирует перемножение больших квадратных матриц с использованием OpenMP и сравнение трёх вариантов распараллеливания по уровням вложенных циклов.

### Структура проекта
```
.
├─ CMakeLists.txt
├─ Dockerfile
├─ README.md
├─ include/
│  ├─ openmp.h
│  └─ utils.h
├─ src/
│  ├─ openmp.cpp
│  └─ utils.cpp
├─ main.cpp
└─ meta/
   └─ task.txt

```

### Ключевые особенности
- **Детерминированная и потокобезопасная инициализация** матриц `A` и `B` без общих ГПСЧ.
- **Предварительное транспонирование `B` → `BT`** для кэш-дружественного доступа (умножение строка-на-строку).
- **Три уровня распараллеливания**:
  - Level 1 (outer): параллелизация по внешнему циклу `i`.
  - Level 2 (middle): параллелизация по среднему циклу `j`.
  - Level 3 (inner): параллелизация по внутреннему циклу `k` с редукцией.
- **Конфигурируемый размер матрицы** через аргумент командной строки (по умолчанию 5000).

### Требования
- Компилятор с поддержкой OpenMP (например, `gcc`/`clang` с ключом `-fopenmp`, MSVC с `/openmp`).
- CMake 3.20+ (рекомендуется).

### Сборка (Windows, CMake)
```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build --config Release -j
```

Собранный исполняемый файл будет находиться в `build/` (например, `build/DAA.exe`).

### Запуск
- По умолчанию размер матриц — 5000x5000.
```bash
./build/DAA.exe
```

- Указать размер матрицы (например, 500x500):
```bash
./build/DAA.exe 500
```

Программа выводит заголовок, рассчитывает эталонный результат на 1 потоке, затем для каждого уровня параллелизации печатает таблицу со столбцами: `Threads`, `Time (s)`, `Speedup`, `Correct`.

### Основные файлы
- `main.cpp`: CLI (аргумент размера), запуск бенчмарка, верификация результатов.
- `include/openmp.h`, `src/openmp.cpp`: класс `MatrixMultiplier`, инициализация, транспонирование `B` → `BT`, три реализации умножения.
- `include/utils.h`, `src/utils.cpp`: измерение времени выполнения выбранного метода.
- `meta/task.txt`: формулировка задания.

### Примечания по производительности
- Транспонирование `B` существенно улучшает локальность данных и снижает пропуски кэша.
- Для больших размеров матрицы имеет смысл запускать в режиме Release и варьировать число потоков (`OMP_NUM_THREADS` либо встроенная переборка 1/2/4/8/16).
- При необходимости можно добавить блочное умножение (tiling) и изменять `schedule(static|dynamic[,chunk])` в `#pragma omp` для подстройки под архитектуру CPU.